import { RankedChoiceVote, Strategy } from './types';
/**
 * Runs the complete Instant Runoff Voting (IRV) algorithm and returns the final results.
 *
 * Executes all elimination rounds until a winner is determined or fewer than 3 candidates remain.
 * Each round eliminates the candidate with the fewest votes and redistributes their votes
 * to voters' next preferences.
 *
 * @param votes - Array of valid ranked choice votes to process
 * @returns Array of tuples representing the final candidate rankings, sorted by vote count (highest first).
 *          Each tuple contains [candidateIndex, [totalBalance, scoresArray]] where:
 *          - totalBalance: Sum of voting power from all voters who support this candidate
 *          - scoresArray: Breakdown of that voting power by voting strategy
 *          The relationship: totalBalance === scoresArray.reduce((a,b) => a + b, 0)
 *
 * @example
 * // Returns final results after IRV elimination rounds
 * // [["2", [150, [60,50,40]]], ["1", [120, [70,30,20]]], ...]
 * // Candidate 2 wins with 150 total voting power (60+50+40 from 3 strategies)
 * // Candidate 1 has 120 total voting power (70+30+20 from 3 strategies)
 */
export declare function getFinalRound(votes: RankedChoiceVote[]): [string, [number, number[]]][];
export default class RankedChoiceVoting {
    proposal: {
        choices: string[];
    };
    votes: RankedChoiceVote[];
    strategies: Strategy[];
    selected: number[];
    constructor(proposal: {
        choices: string[];
    }, votes: RankedChoiceVote[], strategies: Strategy[], selected: number[]);
    static isValidChoice(voteChoice: number[], proposalChoices: string[]): boolean;
    getValidVotes(): RankedChoiceVote[];
    getScores(): number[];
    getScoresByStrategy(): number[][];
    /**
     * Returns the total voting power from all submitted votes, including invalid ones.
     *
     * This method sums the balance (voting power) from ALL votes submitted to the proposal,
     * regardless of whether they have valid choice arrays. This is useful for calculating
     * total participation, quorum requirements, and percentage of total voting power.
     *
     * Note: This differs from IRV final results which only include valid votes. Invalid votes
     * are excluded from IRV calculations but their voting power is still counted here for
     * participation metrics.
     *
     * @returns Total voting power from all votes (valid + invalid)
     *
     * @example
     * // votes = [
     * //   { choice: [1,2,3,4], balance: 1000 }, // Valid
     * //   { choice: [1,5,2], balance: 500 },    // Invalid (index 5)
     * //   { choice: [2,1,4,3], balance: 750 }   // Valid
     * // ]
     * // Returns: 2250 (includes invalid vote's 500 balance)
     */
    getScoresTotal(): number;
    /**
     * Converts the selected choice indices into a human-readable string representation.
     *
     * Note: This method supports partial ranking where not all available choices
     * need to be selected. The ordinal positions (1st, 2nd, etc.) reflect the
     * order of valid selections only. Invalid choice indices are filtered out.
     *
     * @returns A formatted string showing the ranked choices with ordinal positions.
     * Only valid choices are included, invalid indices are silently ignored.
     *
     * @example
     * // With choices ['Alice', 'Bob', 'Carol', 'David'] and selected [1, 3, 2]
     * // Returns: "(1st) Alice, (2nd) Carol, (3rd) Bob"
     *
     * @example
     * // Partial ranking with choices ['Alice', 'Bob', 'Carol', 'David'] and selected [4, 1]
     * // Returns: "(1st) David, (2nd) Alice"
     *
     * @example
     * // With invalid choice index 5 in selected [1, 5]
     * // Returns: "(1st) Alice" - invalid choice 5 is filtered out
     */
    getChoiceString(): string;
}
